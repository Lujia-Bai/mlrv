# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
#' @name Heter_LRV
#' @title Long-run covariance matrix estimators
#' @description \loadmathjax The function provides a wide range of estimators for the long-run covariance matrix estimation in non-stationary time series with covariante.
#' @param e, vector, if the plug-in estimator is used, e should be the vector of residuals, OLS or nonparametric ones. If the difference-based debiased method is adopted, e should be the reponse time series, i.e., \mjseqn{y}. Specially, e should also be the reponse time series, i.e., \mjseqn{y}, if the plug-in estimator using the \mjseqn{\breve{\beta}}, the pilot estimator proposed in Bai and Wu (2023).
#' @param X, a matrix \mjseqn{n\times p}
#' @param m, integer, the window size.
#' @param tau_n, double, the smoothing parameter in the estimator. If tau_n is 0, a rule-of-thumb value will be automatically used.
#' @param lrv_method, the method of long-run variance estimation, lrvmethod = 0 uses the plug-in estimator in Zhou (2010), lrvmethod = 1 offers the debias difference-based estimator in Bai and Wu (2023), lrvmethod = 2 provides the plug-in estimator using the \mjseqn{\breve{\beta}}, the pilot estimator proposed in Bai and Wu (2023)
#' @param ind,  types of kernels
#'* 1 Triangular \mjseqn{1-|u|}, \mjseqn{u \le 1}
#'* 2 Epanechnikov kernel \mjseqn{3/4(1-u^{2})}, \mjseqn{u \le 1}
#'* 3 Quartic \mjseqn{15/16(1-u^{2})^{2}}, \mjseqn{u \le 1}
#'* 4 Triweight \mjseqn{35/32(1-u^{2})^{3}}, \mjseqn{u \le 1}
#'* 5 Tricube  \mjseqn{70/81(1-|u|^{3})^{3}}, \mjseqn{u \le 1}
#' @param print_deg, bool, whether to print information of non-positiveness, default 0\mjseqn{n\times p}{}
#' @param rescale, bool, whether to use rescaling to correct the negative eigenvalues, default 0
NULL

#' @export
NULL

#' @export
#' @name loc_constant
#' @title Nonparametric smoothing
#' @param bw, double, bandwidth, between 0 and 1.
#' @param x, vector, covariates
#' @param y, matrix, response variables
#' @param db_kernel, bool, whether to use jackknife kernel, default 0,
#' @return a matrix of smoothed values
loc_constant <- function(bw, x, y, db_kernel = 0L) {
    .Call(`_mlrv_loc_constant`, bw, x, y, db_kernel)
}

#' @export
#' @name LocLinear
#' @title Local linear Regression
#' @description  Local linear estimates for time varying coefficients
#' @param bw double, bandwith
#' @param t vector, time, 1:n/n
#' @param y vector, response series to be tested for long memory in the next step
#' @param X matrix, covariates matrix
#' @param db_kernel bool, whether to use jackknife kernel, default 0
#' @param deriv2 bool,whether to return second-order derivative, default 0
#' @param scb bool, whether to use the result for futher calculation of simulataneous confidence bands.
#' @return a list of results
#' \itemize{
#' \item mu: the estimated trend
#' \item beta0: time varying coefficient
#' \item X_reg: a matrix whose j'th row is \mjseqn{x_j^T\hat{M}(t_j)}
#' \item t: 1:n/n
#' \item bw: bandwidth used
#' \item X: covariates matrox
#' \item y: response
#' \item n: sample size
#' \item p: dimenstion of covariates including the intercept
#' \item invM: inversion of M matrix, when scb = 1
#' }
#' @details
#' The time varying coefficients are estimated by
#' \mjsdeqn{(\hat{\boldsymbol{\beta}}_{b_{n}}(t), \hat{\boldsymbol{\beta}}_{b_{n}}^{\prime}(t)) = \mathbf{arg min}_{\eta_{0},\eta_{1}}[\sum_{i=1}^{n}\{y_{i}-\mathbf{x}_{i}^{\mathrm{T}}\eta_{0}-\mathbf{x}_{i}^{\mathrm{T}} \eta_{1}(t_{i}-t)\}^{2} \boldsymbol{K}_{b_{n}}(t_{i}-t)]}
#' where beta0 is \mjseqn{\hat{\boldsymbol{\beta}}_{b_{n}}(t)}, mu is \mjseqn{X^T \hat{\boldsymbol{\beta}}_{b_{n}}(t)}
#' @references
#' Zhou, Z., & Wu, W. B. (2010). Simultaneous inference of linear models with time varying coefficients. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 72(4), 513-531.
LocLinear <- function(bw, t, y, X, db_kernel = 0L, deriv2 = 0L, scb = 0L) {
    .Call(`_mlrv_LocLinear`, bw, t, y, X, db_kernel, deriv2, scb)
}

#' @export
#' @name sim_T
#' @title bootstrap distribution
#' @description  bootstrap distribution of the gradient based structural stability test
#' @param X, matrix of covariates
#' @param t, vector of time points
#' @param sigma, a cube of long-run covariance function.
#' @param m, int value of window size
#' @param B, int, number of iteration
#' @param type type of tests, residual-based or coefficient-based
#' @return a vector of bootstrap statistic
sim_T <- function(X, t, sigma, m, B, type = 0L) {
    .Call(`_mlrv_sim_T`, X, t, sigma, m, B, type)
}

Diff1 <- function(e, X, m, tau_n = 0, ind = 2L) {
    .Call(`_mlrv_Diff1`, e, X, m, tau_n, ind)
}

DiffX <- function(X, m, tau_n = 0, ind = 2L) {
    .Call(`_mlrv_DiffX`, X, m, tau_n, ind)
}

DiffA <- function(y, X, m, tau_n = 0, ind = 2L) {
    .Call(`_mlrv_DiffA`, y, X, m, tau_n, ind)
}

#' Bai, L., & Wu, W. (2023). Difference-based covariance matrix estimate in time series nonparametric regression with applications to specification tests.
#'
#' Zhou, Z. and Wu, W. B. (2010). Simultaneous inference of linear models with time varying coefficients.J. R. Stat. Soc. Ser. B. Stat. Methodol., 72(4):513â€“531.
Heter_LRV <- function(e, X, m, tau_n = 0, lrv_method = 1L, ind = 2L, print_deg = 0L, rescale = 0L) {
    .Call(`_mlrv_Heter_LRV`, e, X, m, tau_n, lrv_method, ind, print_deg, rescale)
}

sim_Phi_heter <- function(data, B, sigma, R) {
    .Call(`_mlrv_sim_Phi_heter`, data, B, sigma, R)
}

sim_Phi_heter_RS <- function(data, B, sigma, R) {
    .Call(`_mlrv_sim_Phi_heter_RS`, data, B, sigma, R)
}

sim_Phi_heter_KS <- function(data, B, sigma, R) {
    .Call(`_mlrv_sim_Phi_heter_KS`, data, B, sigma, R)
}

sim_Phi_heter_VS <- function(data, B, sigma, R) {
    .Call(`_mlrv_sim_Phi_heter_VS`, data, B, sigma, R)
}

#' @export
#' @name gcv_cov
#' @title Generalized Cross Validation
#' @description Given a bandwidth, compute its corresponding GCV value \loadmathjax
#' @param bw double, bandwidth
#' @param t vector, scaled time \mjseqn{[0,1]}
#' @param y vector, response
#' @param X matrix, covariates matrix
#' @param verbose bool, whether to print the numeritor and denominator in GCV value
#' @return GCV value
#' @details
#' Generalized cross validation value is defined as \loadmathjax
#' \mjsdeqn{n^{-1}| Y-\hat{Y}|^2/[1- \mathrm{tr}(Q(b)) / n]^2}
#' When computing \mjseqn{\mathrm{tr}(Q(b))},
#' we use the fact that the first derivative of coefficient function is zero at centern point
#' The ith diagonal value of \mjseqn{Q(b)} is actually \mjseqn{x^T(t_i)S^{-1}_{n}x(t_i)}
#' where \mjseqn{S^{-1}_{n}} means the top left p-dimension sqaure matrix of
#'  \mjseqn{S_{n}(t_i) = X^T W(t_i) X}, \mjseqn{W(t_i)} is the kernel weighted matrix. Details on
#' the computation of \mjseqn{S_n} could be found in \code{LocLinear} and its reference
gcv_cov <- function(bw, t, y, X, verbose = 1L) {
    .Call(`_mlrv_gcv_cov`, bw, t, y, X, verbose)
}

#' @export
#' @name MV_critical
#' @title Statistics-adapted values for extended minimum volatility selection.
#' @description  Calulation of the variance of the bootstrap statistics for the extended minimum volatility selection.
#' @param y, vector, as used in the Heter_LRV
#' @param data, list, a list of data
#' @param R, a cube of standard.normal random variables.
#' @param gridm, vector, a grid of candidate m's.
#' @param gridtau, vector, a grid of candidate tau's.
#' @param type, integer, 1 KPSS 2 RS 3 VS 4 KS
#' @param cvalue, double, 1-qunatile for the calculation of bootstrap variance, default 0.1.
#' @param B, integer, number of iterations for the calculation of bootstrap variance
#' @param lrvmethod, integer, see also Heter_LRV
#' @param ind, integer, the type of kernel,  see also Heter_LRV
#' @param rescale, bool, whether to rescale when positiveness of the matrix is not obtained. default 0
#' @seealso Heter_LRV
#' @return matrix of critical values
#' @references #' Bai, L., and Wu, W. (2023). Detecting long-range dependence for time-varying linear models. To appear in Bernoulli
MV_critical <- function(y, data, R, gridm, gridtau, type = 1L, cvalue = 0.1, B = 100L, lrvmethod = 1L, ind = 2L, rescale = 0L) {
    .Call(`_mlrv_MV_critical`, y, data, R, gridm, gridtau, type, cvalue, B, lrvmethod, ind, rescale)
}

#' @export
#' @name MV_ise_heter_critical
#' @title MV method
#' @description Selection of smoothing parameters for bootstrap tests by choosing the index minimizing the volatility of bootstrap statistics or long-run variance estimators in the neibourhood computed before.
#' @param critical, a matrix of critical values
#' @param neighbour, integer, number of neighbours
#' @return a list of results,
#' \itemize{
#' \item minp: optimal row number
#' \item minq: optimal column number
#' \item min_ise: optimal value
#' }
#' @references #' Bai, L., and Wu, W. (2023). Detecting long-range dependence for time-varying linear models. To appear in Bernoulli
MV_ise_heter_critical <- function(critical, neighbour) {
    .Call(`_mlrv_MV_ise_heter_critical`, critical, neighbour)
}

MV_ise_heter <- function(lrv_cub, dim, n, neighbour) {
    .Call(`_mlrv_MV_ise_heter`, lrv_cub, dim, n, neighbour)
}

MV_cov_heter <- function(e, X, gridm, gridtau, lrv_method = 0L, ind = 2L) {
    .Call(`_mlrv_MV_cov_heter`, e, X, gridm, gridtau, lrv_method, ind)
}

MV_critical_cp <- function(y, X, t, gridm, gridtau, cvalue = 0.1, B = 100L, lrvmethod = 1L, ind = 2L, rescale = 0L) {
    .Call(`_mlrv_MV_critical_cp`, y, X, t, gridm, gridtau, cvalue, B, lrvmethod, ind, rescale)
}

Ctvfdiff <- function(x, d, burnin) {
    .Call(`_mlrv_Ctvfdiff`, x, d, burnin)
}

